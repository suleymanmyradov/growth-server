// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activities.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const countActivities = `-- name: CountActivities :one
SELECT COUNT(*) FROM activities
`

func (q *Queries) CountActivities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesByUser = `-- name: CountActivitiesByUser :one
SELECT COUNT(*) FROM activities WHERE user_id = $1
`

func (q *Queries) CountActivitiesByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesByUserAndType = `-- name: CountActivitiesByUserAndType :one
SELECT COUNT(*) FROM activities WHERE user_id = $1 AND item_type = $2
`

type CountActivitiesByUserAndTypeParams struct {
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
	ItemType string    `db:"item_type" json:"item_type"`
}

func (q *Queries) CountActivitiesByUserAndType(ctx context.Context, arg CountActivitiesByUserAndTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByUserAndType, arg.UserID, arg.ItemType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivity = `-- name: CreateActivity :one
INSERT INTO activities (item_type, title, description, metadata, user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, item_type, title, description, metadata, user_id, created_at
`

type CreateActivityParams struct {
	ItemType    string                `db:"item_type" json:"item_type"`
	Title       string                `db:"title" json:"title"`
	Description sql.NullString        `db:"description" json:"description"`
	Metadata    pqtype.NullRawMessage `db:"metadata" json:"metadata"`
	UserID      uuid.UUID             `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) (Activity, error) {
	row := q.db.QueryRowContext(ctx, createActivity,
		arg.ItemType,
		arg.Title,
		arg.Description,
		arg.Metadata,
		arg.UserID,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.Title,
		&i.Description,
		&i.Metadata,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteActivitiesByUser = `-- name: DeleteActivitiesByUser :exec
DELETE FROM activities WHERE user_id = $1
`

func (q *Queries) DeleteActivitiesByUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteActivitiesByUser, userID)
	return err
}

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM activities WHERE id = $1
`

func (q *Queries) DeleteActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteActivity, id)
	return err
}

const getAchievements = `-- name: GetAchievements :many
WITH user_activities AS (
    SELECT id, item_type, title, description, metadata, user_id, created_at FROM activities WHERE user_id = $1
), achievement_rows AS (
    SELECT 'first_activity'::text AS id,
           'First Activity'::text AS name,
           'Complete your first activity'::text AS description,
           NULL::text AS icon_url,
           MIN(created_at) AS unlocked_at
    FROM user_activities
    UNION ALL
    SELECT 'habit_10', 'Habit Enthusiast', 'Complete 10 habits', NULL,
           MAX(created_at)
    FROM user_activities WHERE item_type = 'habit_completed'
    GROUP BY user_id HAVING COUNT(*) >= 10
    UNION ALL
    SELECT 'goal_5', 'Goal Crusher', 'Complete 5 goals', NULL,
           MAX(created_at)
    FROM user_activities WHERE item_type = 'goal_completed'
    GROUP BY user_id HAVING COUNT(*) >= 5
)
SELECT id, name, description, icon_url, unlocked_at
FROM achievement_rows
ORDER BY unlocked_at NULLS LAST
`

type GetAchievementsRow struct {
	ID          string         `db:"id" json:"id"`
	Name        string         `db:"name" json:"name"`
	Description string         `db:"description" json:"description"`
	IconUrl     sql.NullString `db:"icon_url" json:"icon_url"`
	UnlockedAt  interface{}    `db:"unlocked_at" json:"unlocked_at"`
}

func (q *Queries) GetAchievements(ctx context.Context, userID uuid.UUID) ([]GetAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievements, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchievementsRow
	for rows.Next() {
		var i GetAchievementsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IconUrl,
			&i.UnlockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivity = `-- name: GetActivity :one
SELECT id, item_type, title, description, metadata, user_id, created_at FROM activities WHERE id = $1
`

func (q *Queries) GetActivity(ctx context.Context, id uuid.UUID) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getActivity, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.Title,
		&i.Description,
		&i.Metadata,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityCalendar = `-- name: GetActivityCalendar :many
SELECT DATE(created_at) AS day,
       COUNT(*) AS activity_count
FROM activities
WHERE user_id = $1
  AND created_at >= $2
  AND created_at < $3
GROUP BY 1
ORDER BY day
`

type GetActivityCalendarParams struct {
	UserID      uuid.UUID    `db:"user_id" json:"user_id"`
	CreatedAt   sql.NullTime `db:"created_at" json:"created_at"`
	CreatedAt_2 sql.NullTime `db:"created_at_2" json:"created_at_2"`
}

type GetActivityCalendarRow struct {
	Day           time.Time `db:"day" json:"day"`
	ActivityCount int64     `db:"activity_count" json:"activity_count"`
}

func (q *Queries) GetActivityCalendar(ctx context.Context, arg GetActivityCalendarParams) ([]GetActivityCalendarRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityCalendar, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivityCalendarRow
	for rows.Next() {
		var i GetActivityCalendarRow
		if err := rows.Scan(&i.Day, &i.ActivityCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityFeed = `-- name: GetActivityFeed :many
SELECT id, item_type, title, description, metadata, user_id, created_at
FROM activities
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetActivityFeedParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetActivityFeed(ctx context.Context, arg GetActivityFeedParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getActivityFeed, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.Title,
			&i.Description,
			&i.Metadata,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityStats = `-- name: GetActivityStats :one
SELECT
    COUNT(*) AS total_activities,
    SUM(CASE WHEN item_type = 'habit_completed' THEN 1 ELSE 0 END) AS habit_completed,
    SUM(CASE WHEN item_type = 'goal_created' THEN 1 ELSE 0 END) AS goal_created,
    SUM(CASE WHEN item_type = 'goal_completed' THEN 1 ELSE 0 END) AS goal_completed,
    SUM(CASE WHEN item_type = 'article_saved' THEN 1 ELSE 0 END) AS article_saved
FROM activities
WHERE user_id = $1
`

type GetActivityStatsRow struct {
	TotalActivities int64 `db:"total_activities" json:"total_activities"`
	HabitCompleted  int64 `db:"habit_completed" json:"habit_completed"`
	GoalCreated     int64 `db:"goal_created" json:"goal_created"`
	GoalCompleted   int64 `db:"goal_completed" json:"goal_completed"`
	ArticleSaved    int64 `db:"article_saved" json:"article_saved"`
}

func (q *Queries) GetActivityStats(ctx context.Context, userID uuid.UUID) (GetActivityStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getActivityStats, userID)
	var i GetActivityStatsRow
	err := row.Scan(
		&i.TotalActivities,
		&i.HabitCompleted,
		&i.GoalCreated,
		&i.GoalCompleted,
		&i.ArticleSaved,
	)
	return i, err
}

const getStreaks = `-- name: GetStreaks :one
WITH days AS (
    SELECT DISTINCT DATE(created_at) AS day
    FROM activities
    WHERE user_id = $1
), ordered_days AS (
    SELECT day, ROW_NUMBER() OVER (ORDER BY day) AS rn
    FROM days
), streak_groups AS (
    SELECT day, rn, day - (rn || ' days')::interval AS grp
    FROM ordered_days
), streak_lengths AS (
    SELECT MIN(day) AS start_day, MAX(day) AS end_day, COUNT(*) AS length
    FROM streak_groups
    GROUP BY grp
), current_streak AS (
    SELECT length
    FROM streak_lengths
    WHERE end_day = (SELECT MAX(day) FROM days)
    LIMIT 1
), longest_streak AS (
    SELECT MAX(length) AS length FROM streak_lengths
)
SELECT
    COALESCE((SELECT length FROM current_streak), 0) AS current_streak,
    COALESCE((SELECT length FROM longest_streak), 0) AS longest_streak
`

type GetStreaksRow struct {
	CurrentStreak interface{} `db:"current_streak" json:"current_streak"`
	LongestStreak interface{} `db:"longest_streak" json:"longest_streak"`
}

func (q *Queries) GetStreaks(ctx context.Context, userID uuid.UUID) (GetStreaksRow, error) {
	row := q.db.QueryRowContext(ctx, getStreaks, userID)
	var i GetStreaksRow
	err := row.Scan(&i.CurrentStreak, &i.LongestStreak)
	return i, err
}

const listActivities = `-- name: ListActivities :many
SELECT id, item_type, title, description, metadata, user_id, created_at FROM activities
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListActivitiesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListActivities(ctx context.Context, arg ListActivitiesParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.Title,
			&i.Description,
			&i.Metadata,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByType = `-- name: ListActivitiesByType :many
SELECT id, item_type, title, description, metadata, user_id, created_at FROM activities WHERE user_id = $1 AND item_type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListActivitiesByTypeParams struct {
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
	ItemType string    `db:"item_type" json:"item_type"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListActivitiesByType(ctx context.Context, arg ListActivitiesByTypeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByType,
		arg.UserID,
		arg.ItemType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.Title,
			&i.Description,
			&i.Metadata,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByUser = `-- name: ListActivitiesByUser :many
SELECT id, item_type, title, description, metadata, user_id, created_at FROM activities WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivitiesByUserParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListActivitiesByUser(ctx context.Context, arg ListActivitiesByUserParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.Title,
			&i.Description,
			&i.Metadata,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logActivity = `-- name: LogActivity :one
INSERT INTO activities (item_type, title, description, metadata, user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, item_type, title, description, metadata, user_id, created_at
`

type LogActivityParams struct {
	ItemType    string                `db:"item_type" json:"item_type"`
	Title       string                `db:"title" json:"title"`
	Description sql.NullString        `db:"description" json:"description"`
	Metadata    pqtype.NullRawMessage `db:"metadata" json:"metadata"`
	UserID      uuid.UUID             `db:"user_id" json:"user_id"`
}

func (q *Queries) LogActivity(ctx context.Context, arg LogActivityParams) (Activity, error) {
	row := q.db.QueryRowContext(ctx, logActivity,
		arg.ItemType,
		arg.Title,
		arg.Description,
		arg.Metadata,
		arg.UserID,
	)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.Title,
		&i.Description,
		&i.Metadata,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}
