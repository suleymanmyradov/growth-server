// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: services/microservices/client/api/v1/client.proto

package client

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Activity_GetActivityFeed_FullMethodName     = "/client.Activity/GetActivityFeed"
	Activity_LogActivity_FullMethodName         = "/client.Activity/LogActivity"
	Activity_GetActivityStats_FullMethodName    = "/client.Activity/GetActivityStats"
	Activity_GetStreaks_FullMethodName          = "/client.Activity/GetStreaks"
	Activity_GetAchievements_FullMethodName     = "/client.Activity/GetAchievements"
	Activity_GetActivityCalendar_FullMethodName = "/client.Activity/GetActivityCalendar"
)

// ActivityClient is the client API for Activity service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ActivityClient interface {
	GetActivityFeed(ctx context.Context, in *GetActivityFeedRequest, opts ...grpc.CallOption) (*GetActivityFeedResponse, error)
	LogActivity(ctx context.Context, in *LogActivityRequest, opts ...grpc.CallOption) (*LogActivityResponse, error)
	GetActivityStats(ctx context.Context, in *GetActivityStatsRequest, opts ...grpc.CallOption) (*GetActivityStatsResponse, error)
	GetStreaks(ctx context.Context, in *GetStreaksRequest, opts ...grpc.CallOption) (*GetStreaksResponse, error)
	GetAchievements(ctx context.Context, in *GetAchievementsRequest, opts ...grpc.CallOption) (*GetAchievementsResponse, error)
	GetActivityCalendar(ctx context.Context, in *GetActivityCalendarRequest, opts ...grpc.CallOption) (*GetActivityCalendarResponse, error)
}

type activityClient struct {
	cc grpc.ClientConnInterface
}

func NewActivityClient(cc grpc.ClientConnInterface) ActivityClient {
	return &activityClient{cc}
}

func (c *activityClient) GetActivityFeed(ctx context.Context, in *GetActivityFeedRequest, opts ...grpc.CallOption) (*GetActivityFeedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActivityFeedResponse)
	err := c.cc.Invoke(ctx, Activity_GetActivityFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityClient) LogActivity(ctx context.Context, in *LogActivityRequest, opts ...grpc.CallOption) (*LogActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogActivityResponse)
	err := c.cc.Invoke(ctx, Activity_LogActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityClient) GetActivityStats(ctx context.Context, in *GetActivityStatsRequest, opts ...grpc.CallOption) (*GetActivityStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActivityStatsResponse)
	err := c.cc.Invoke(ctx, Activity_GetActivityStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityClient) GetStreaks(ctx context.Context, in *GetStreaksRequest, opts ...grpc.CallOption) (*GetStreaksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStreaksResponse)
	err := c.cc.Invoke(ctx, Activity_GetStreaks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityClient) GetAchievements(ctx context.Context, in *GetAchievementsRequest, opts ...grpc.CallOption) (*GetAchievementsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAchievementsResponse)
	err := c.cc.Invoke(ctx, Activity_GetAchievements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityClient) GetActivityCalendar(ctx context.Context, in *GetActivityCalendarRequest, opts ...grpc.CallOption) (*GetActivityCalendarResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActivityCalendarResponse)
	err := c.cc.Invoke(ctx, Activity_GetActivityCalendar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActivityServer is the server API for Activity service.
// All implementations must embed UnimplementedActivityServer
// for forward compatibility.
type ActivityServer interface {
	GetActivityFeed(context.Context, *GetActivityFeedRequest) (*GetActivityFeedResponse, error)
	LogActivity(context.Context, *LogActivityRequest) (*LogActivityResponse, error)
	GetActivityStats(context.Context, *GetActivityStatsRequest) (*GetActivityStatsResponse, error)
	GetStreaks(context.Context, *GetStreaksRequest) (*GetStreaksResponse, error)
	GetAchievements(context.Context, *GetAchievementsRequest) (*GetAchievementsResponse, error)
	GetActivityCalendar(context.Context, *GetActivityCalendarRequest) (*GetActivityCalendarResponse, error)
	mustEmbedUnimplementedActivityServer()
}

// UnimplementedActivityServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedActivityServer struct{}

func (UnimplementedActivityServer) GetActivityFeed(context.Context, *GetActivityFeedRequest) (*GetActivityFeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivityFeed not implemented")
}
func (UnimplementedActivityServer) LogActivity(context.Context, *LogActivityRequest) (*LogActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogActivity not implemented")
}
func (UnimplementedActivityServer) GetActivityStats(context.Context, *GetActivityStatsRequest) (*GetActivityStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivityStats not implemented")
}
func (UnimplementedActivityServer) GetStreaks(context.Context, *GetStreaksRequest) (*GetStreaksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStreaks not implemented")
}
func (UnimplementedActivityServer) GetAchievements(context.Context, *GetAchievementsRequest) (*GetAchievementsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAchievements not implemented")
}
func (UnimplementedActivityServer) GetActivityCalendar(context.Context, *GetActivityCalendarRequest) (*GetActivityCalendarResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivityCalendar not implemented")
}
func (UnimplementedActivityServer) mustEmbedUnimplementedActivityServer() {}
func (UnimplementedActivityServer) testEmbeddedByValue()                  {}

// UnsafeActivityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActivityServer will
// result in compilation errors.
type UnsafeActivityServer interface {
	mustEmbedUnimplementedActivityServer()
}

func RegisterActivityServer(s grpc.ServiceRegistrar, srv ActivityServer) {
	// If the following call pancis, it indicates UnimplementedActivityServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Activity_ServiceDesc, srv)
}

func _Activity_GetActivityFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActivityFeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).GetActivityFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_GetActivityFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).GetActivityFeed(ctx, req.(*GetActivityFeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activity_LogActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).LogActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_LogActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).LogActivity(ctx, req.(*LogActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activity_GetActivityStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActivityStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).GetActivityStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_GetActivityStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).GetActivityStats(ctx, req.(*GetActivityStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activity_GetStreaks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStreaksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).GetStreaks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_GetStreaks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).GetStreaks(ctx, req.(*GetStreaksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activity_GetAchievements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAchievementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).GetAchievements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_GetAchievements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).GetAchievements(ctx, req.(*GetAchievementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activity_GetActivityCalendar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActivityCalendarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).GetActivityCalendar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_GetActivityCalendar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).GetActivityCalendar(ctx, req.(*GetActivityCalendarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Activity_ServiceDesc is the grpc.ServiceDesc for Activity service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Activity_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Activity",
	HandlerType: (*ActivityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActivityFeed",
			Handler:    _Activity_GetActivityFeed_Handler,
		},
		{
			MethodName: "LogActivity",
			Handler:    _Activity_LogActivity_Handler,
		},
		{
			MethodName: "GetActivityStats",
			Handler:    _Activity_GetActivityStats_Handler,
		},
		{
			MethodName: "GetStreaks",
			Handler:    _Activity_GetStreaks_Handler,
		},
		{
			MethodName: "GetAchievements",
			Handler:    _Activity_GetAchievements_Handler,
		},
		{
			MethodName: "GetActivityCalendar",
			Handler:    _Activity_GetActivityCalendar_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}

const (
	Notifications_CreateNotification_FullMethodName            = "/client.Notifications/CreateNotification"
	Notifications_GetNotification_FullMethodName               = "/client.Notifications/GetNotification"
	Notifications_ListNotifications_FullMethodName             = "/client.Notifications/ListNotifications"
	Notifications_MarkNotificationRead_FullMethodName          = "/client.Notifications/MarkNotificationRead"
	Notifications_MarkAllNotificationsRead_FullMethodName      = "/client.Notifications/MarkAllNotificationsRead"
	Notifications_DeleteNotification_FullMethodName            = "/client.Notifications/DeleteNotification"
	Notifications_GetUnreadCount_FullMethodName                = "/client.Notifications/GetUnreadCount"
	Notifications_GetNotificationPreferences_FullMethodName    = "/client.Notifications/GetNotificationPreferences"
	Notifications_UpdateNotificationPreferences_FullMethodName = "/client.Notifications/UpdateNotificationPreferences"
	Notifications_GetNotificationTypes_FullMethodName          = "/client.Notifications/GetNotificationTypes"
)

// NotificationsClient is the client API for Notifications service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationsClient interface {
	CreateNotification(ctx context.Context, in *CreateNotificationRequest, opts ...grpc.CallOption) (*CreateNotificationResponse, error)
	GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationResponse, error)
	ListNotifications(ctx context.Context, in *ListNotificationsRequest, opts ...grpc.CallOption) (*ListNotificationsResponse, error)
	MarkNotificationRead(ctx context.Context, in *MarkNotificationReadRequest, opts ...grpc.CallOption) (*MarkNotificationReadResponse, error)
	MarkAllNotificationsRead(ctx context.Context, in *MarkAllNotificationsReadRequest, opts ...grpc.CallOption) (*MarkAllNotificationsReadResponse, error)
	DeleteNotification(ctx context.Context, in *DeleteNotificationRequest, opts ...grpc.CallOption) (*DeleteNotificationResponse, error)
	GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error)
	GetNotificationPreferences(ctx context.Context, in *GetNotificationPreferencesRequest, opts ...grpc.CallOption) (*GetNotificationPreferencesResponse, error)
	UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*UpdateNotificationPreferencesResponse, error)
	GetNotificationTypes(ctx context.Context, in *GetNotificationTypesRequest, opts ...grpc.CallOption) (*GetNotificationTypesResponse, error)
}

type notificationsClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationsClient(cc grpc.ClientConnInterface) NotificationsClient {
	return &notificationsClient{cc}
}

func (c *notificationsClient) CreateNotification(ctx context.Context, in *CreateNotificationRequest, opts ...grpc.CallOption) (*CreateNotificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNotificationResponse)
	err := c.cc.Invoke(ctx, Notifications_CreateNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNotificationResponse)
	err := c.cc.Invoke(ctx, Notifications_GetNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) ListNotifications(ctx context.Context, in *ListNotificationsRequest, opts ...grpc.CallOption) (*ListNotificationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNotificationsResponse)
	err := c.cc.Invoke(ctx, Notifications_ListNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) MarkNotificationRead(ctx context.Context, in *MarkNotificationReadRequest, opts ...grpc.CallOption) (*MarkNotificationReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkNotificationReadResponse)
	err := c.cc.Invoke(ctx, Notifications_MarkNotificationRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) MarkAllNotificationsRead(ctx context.Context, in *MarkAllNotificationsReadRequest, opts ...grpc.CallOption) (*MarkAllNotificationsReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkAllNotificationsReadResponse)
	err := c.cc.Invoke(ctx, Notifications_MarkAllNotificationsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) DeleteNotification(ctx context.Context, in *DeleteNotificationRequest, opts ...grpc.CallOption) (*DeleteNotificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteNotificationResponse)
	err := c.cc.Invoke(ctx, Notifications_DeleteNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUnreadCountResponse)
	err := c.cc.Invoke(ctx, Notifications_GetUnreadCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) GetNotificationPreferences(ctx context.Context, in *GetNotificationPreferencesRequest, opts ...grpc.CallOption) (*GetNotificationPreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNotificationPreferencesResponse)
	err := c.cc.Invoke(ctx, Notifications_GetNotificationPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*UpdateNotificationPreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateNotificationPreferencesResponse)
	err := c.cc.Invoke(ctx, Notifications_UpdateNotificationPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationsClient) GetNotificationTypes(ctx context.Context, in *GetNotificationTypesRequest, opts ...grpc.CallOption) (*GetNotificationTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNotificationTypesResponse)
	err := c.cc.Invoke(ctx, Notifications_GetNotificationTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationsServer is the server API for Notifications service.
// All implementations must embed UnimplementedNotificationsServer
// for forward compatibility.
type NotificationsServer interface {
	CreateNotification(context.Context, *CreateNotificationRequest) (*CreateNotificationResponse, error)
	GetNotification(context.Context, *GetNotificationRequest) (*GetNotificationResponse, error)
	ListNotifications(context.Context, *ListNotificationsRequest) (*ListNotificationsResponse, error)
	MarkNotificationRead(context.Context, *MarkNotificationReadRequest) (*MarkNotificationReadResponse, error)
	MarkAllNotificationsRead(context.Context, *MarkAllNotificationsReadRequest) (*MarkAllNotificationsReadResponse, error)
	DeleteNotification(context.Context, *DeleteNotificationRequest) (*DeleteNotificationResponse, error)
	GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error)
	GetNotificationPreferences(context.Context, *GetNotificationPreferencesRequest) (*GetNotificationPreferencesResponse, error)
	UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*UpdateNotificationPreferencesResponse, error)
	GetNotificationTypes(context.Context, *GetNotificationTypesRequest) (*GetNotificationTypesResponse, error)
	mustEmbedUnimplementedNotificationsServer()
}

// UnimplementedNotificationsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationsServer struct{}

func (UnimplementedNotificationsServer) CreateNotification(context.Context, *CreateNotificationRequest) (*CreateNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotification not implemented")
}
func (UnimplementedNotificationsServer) GetNotification(context.Context, *GetNotificationRequest) (*GetNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotification not implemented")
}
func (UnimplementedNotificationsServer) ListNotifications(context.Context, *ListNotificationsRequest) (*ListNotificationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifications not implemented")
}
func (UnimplementedNotificationsServer) MarkNotificationRead(context.Context, *MarkNotificationReadRequest) (*MarkNotificationReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkNotificationRead not implemented")
}
func (UnimplementedNotificationsServer) MarkAllNotificationsRead(context.Context, *MarkAllNotificationsReadRequest) (*MarkAllNotificationsReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAllNotificationsRead not implemented")
}
func (UnimplementedNotificationsServer) DeleteNotification(context.Context, *DeleteNotificationRequest) (*DeleteNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotification not implemented")
}
func (UnimplementedNotificationsServer) GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnreadCount not implemented")
}
func (UnimplementedNotificationsServer) GetNotificationPreferences(context.Context, *GetNotificationPreferencesRequest) (*GetNotificationPreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationPreferences not implemented")
}
func (UnimplementedNotificationsServer) UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*UpdateNotificationPreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotificationPreferences not implemented")
}
func (UnimplementedNotificationsServer) GetNotificationTypes(context.Context, *GetNotificationTypesRequest) (*GetNotificationTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationTypes not implemented")
}
func (UnimplementedNotificationsServer) mustEmbedUnimplementedNotificationsServer() {}
func (UnimplementedNotificationsServer) testEmbeddedByValue()                       {}

// UnsafeNotificationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationsServer will
// result in compilation errors.
type UnsafeNotificationsServer interface {
	mustEmbedUnimplementedNotificationsServer()
}

func RegisterNotificationsServer(s grpc.ServiceRegistrar, srv NotificationsServer) {
	// If the following call pancis, it indicates UnimplementedNotificationsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Notifications_ServiceDesc, srv)
}

func _Notifications_CreateNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).CreateNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_CreateNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).CreateNotification(ctx, req.(*CreateNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_GetNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).GetNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_GetNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).GetNotification(ctx, req.(*GetNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_ListNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).ListNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_ListNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).ListNotifications(ctx, req.(*ListNotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_MarkNotificationRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkNotificationReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).MarkNotificationRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_MarkNotificationRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).MarkNotificationRead(ctx, req.(*MarkNotificationReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_MarkAllNotificationsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAllNotificationsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).MarkAllNotificationsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_MarkAllNotificationsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).MarkAllNotificationsRead(ctx, req.(*MarkAllNotificationsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_DeleteNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).DeleteNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_DeleteNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).DeleteNotification(ctx, req.(*DeleteNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_GetUnreadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnreadCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).GetUnreadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_GetUnreadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).GetUnreadCount(ctx, req.(*GetUnreadCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_GetNotificationPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).GetNotificationPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_GetNotificationPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).GetNotificationPreferences(ctx, req.(*GetNotificationPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_UpdateNotificationPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNotificationPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).UpdateNotificationPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_UpdateNotificationPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).UpdateNotificationPreferences(ctx, req.(*UpdateNotificationPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Notifications_GetNotificationTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationsServer).GetNotificationTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Notifications_GetNotificationTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationsServer).GetNotificationTypes(ctx, req.(*GetNotificationTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Notifications_ServiceDesc is the grpc.ServiceDesc for Notifications service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Notifications_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Notifications",
	HandlerType: (*NotificationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNotification",
			Handler:    _Notifications_CreateNotification_Handler,
		},
		{
			MethodName: "GetNotification",
			Handler:    _Notifications_GetNotification_Handler,
		},
		{
			MethodName: "ListNotifications",
			Handler:    _Notifications_ListNotifications_Handler,
		},
		{
			MethodName: "MarkNotificationRead",
			Handler:    _Notifications_MarkNotificationRead_Handler,
		},
		{
			MethodName: "MarkAllNotificationsRead",
			Handler:    _Notifications_MarkAllNotificationsRead_Handler,
		},
		{
			MethodName: "DeleteNotification",
			Handler:    _Notifications_DeleteNotification_Handler,
		},
		{
			MethodName: "GetUnreadCount",
			Handler:    _Notifications_GetUnreadCount_Handler,
		},
		{
			MethodName: "GetNotificationPreferences",
			Handler:    _Notifications_GetNotificationPreferences_Handler,
		},
		{
			MethodName: "UpdateNotificationPreferences",
			Handler:    _Notifications_UpdateNotificationPreferences_Handler,
		},
		{
			MethodName: "GetNotificationTypes",
			Handler:    _Notifications_GetNotificationTypes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}

const (
	Report_SubmitReport_FullMethodName        = "/client.Report/SubmitReport"
	Report_GetReport_FullMethodName           = "/client.Report/GetReport"
	Report_ListReports_FullMethodName         = "/client.Report/ListReports"
	Report_UpdateReport_FullMethodName        = "/client.Report/UpdateReport"
	Report_GetReportCategories_FullMethodName = "/client.Report/GetReportCategories"
	Report_UploadAttachment_FullMethodName    = "/client.Report/UploadAttachment"
	Report_GetReportStatus_FullMethodName     = "/client.Report/GetReportStatus"
	Report_CloseReport_FullMethodName         = "/client.Report/CloseReport"
	Report_AddReportComment_FullMethodName    = "/client.Report/AddReportComment"
	Report_GetReportComments_FullMethodName   = "/client.Report/GetReportComments"
)

// ReportClient is the client API for Report service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReportClient interface {
	SubmitReport(ctx context.Context, in *SubmitReportRequest, opts ...grpc.CallOption) (*SubmitReportResponse, error)
	GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*GetReportResponse, error)
	ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error)
	UpdateReport(ctx context.Context, in *UpdateReportRequest, opts ...grpc.CallOption) (*UpdateReportResponse, error)
	GetReportCategories(ctx context.Context, in *GetReportCategoriesRequest, opts ...grpc.CallOption) (*GetReportCategoriesResponse, error)
	UploadAttachment(ctx context.Context, in *UploadAttachmentRequest, opts ...grpc.CallOption) (*UploadAttachmentResponse, error)
	GetReportStatus(ctx context.Context, in *GetReportStatusRequest, opts ...grpc.CallOption) (*GetReportStatusResponse, error)
	CloseReport(ctx context.Context, in *CloseReportRequest, opts ...grpc.CallOption) (*CloseReportResponse, error)
	AddReportComment(ctx context.Context, in *AddReportCommentRequest, opts ...grpc.CallOption) (*AddReportCommentResponse, error)
	GetReportComments(ctx context.Context, in *GetReportCommentsRequest, opts ...grpc.CallOption) (*GetReportCommentsResponse, error)
}

type reportClient struct {
	cc grpc.ClientConnInterface
}

func NewReportClient(cc grpc.ClientConnInterface) ReportClient {
	return &reportClient{cc}
}

func (c *reportClient) SubmitReport(ctx context.Context, in *SubmitReportRequest, opts ...grpc.CallOption) (*SubmitReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitReportResponse)
	err := c.cc.Invoke(ctx, Report_SubmitReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*GetReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReportResponse)
	err := c.cc.Invoke(ctx, Report_GetReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReportsResponse)
	err := c.cc.Invoke(ctx, Report_ListReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) UpdateReport(ctx context.Context, in *UpdateReportRequest, opts ...grpc.CallOption) (*UpdateReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateReportResponse)
	err := c.cc.Invoke(ctx, Report_UpdateReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) GetReportCategories(ctx context.Context, in *GetReportCategoriesRequest, opts ...grpc.CallOption) (*GetReportCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReportCategoriesResponse)
	err := c.cc.Invoke(ctx, Report_GetReportCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) UploadAttachment(ctx context.Context, in *UploadAttachmentRequest, opts ...grpc.CallOption) (*UploadAttachmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadAttachmentResponse)
	err := c.cc.Invoke(ctx, Report_UploadAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) GetReportStatus(ctx context.Context, in *GetReportStatusRequest, opts ...grpc.CallOption) (*GetReportStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReportStatusResponse)
	err := c.cc.Invoke(ctx, Report_GetReportStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) CloseReport(ctx context.Context, in *CloseReportRequest, opts ...grpc.CallOption) (*CloseReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseReportResponse)
	err := c.cc.Invoke(ctx, Report_CloseReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) AddReportComment(ctx context.Context, in *AddReportCommentRequest, opts ...grpc.CallOption) (*AddReportCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddReportCommentResponse)
	err := c.cc.Invoke(ctx, Report_AddReportComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportClient) GetReportComments(ctx context.Context, in *GetReportCommentsRequest, opts ...grpc.CallOption) (*GetReportCommentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReportCommentsResponse)
	err := c.cc.Invoke(ctx, Report_GetReportComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReportServer is the server API for Report service.
// All implementations must embed UnimplementedReportServer
// for forward compatibility.
type ReportServer interface {
	SubmitReport(context.Context, *SubmitReportRequest) (*SubmitReportResponse, error)
	GetReport(context.Context, *GetReportRequest) (*GetReportResponse, error)
	ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error)
	UpdateReport(context.Context, *UpdateReportRequest) (*UpdateReportResponse, error)
	GetReportCategories(context.Context, *GetReportCategoriesRequest) (*GetReportCategoriesResponse, error)
	UploadAttachment(context.Context, *UploadAttachmentRequest) (*UploadAttachmentResponse, error)
	GetReportStatus(context.Context, *GetReportStatusRequest) (*GetReportStatusResponse, error)
	CloseReport(context.Context, *CloseReportRequest) (*CloseReportResponse, error)
	AddReportComment(context.Context, *AddReportCommentRequest) (*AddReportCommentResponse, error)
	GetReportComments(context.Context, *GetReportCommentsRequest) (*GetReportCommentsResponse, error)
	mustEmbedUnimplementedReportServer()
}

// UnimplementedReportServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReportServer struct{}

func (UnimplementedReportServer) SubmitReport(context.Context, *SubmitReportRequest) (*SubmitReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitReport not implemented")
}
func (UnimplementedReportServer) GetReport(context.Context, *GetReportRequest) (*GetReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedReportServer) ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReports not implemented")
}
func (UnimplementedReportServer) UpdateReport(context.Context, *UpdateReportRequest) (*UpdateReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReport not implemented")
}
func (UnimplementedReportServer) GetReportCategories(context.Context, *GetReportCategoriesRequest) (*GetReportCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportCategories not implemented")
}
func (UnimplementedReportServer) UploadAttachment(context.Context, *UploadAttachmentRequest) (*UploadAttachmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadAttachment not implemented")
}
func (UnimplementedReportServer) GetReportStatus(context.Context, *GetReportStatusRequest) (*GetReportStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportStatus not implemented")
}
func (UnimplementedReportServer) CloseReport(context.Context, *CloseReportRequest) (*CloseReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseReport not implemented")
}
func (UnimplementedReportServer) AddReportComment(context.Context, *AddReportCommentRequest) (*AddReportCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReportComment not implemented")
}
func (UnimplementedReportServer) GetReportComments(context.Context, *GetReportCommentsRequest) (*GetReportCommentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReportComments not implemented")
}
func (UnimplementedReportServer) mustEmbedUnimplementedReportServer() {}
func (UnimplementedReportServer) testEmbeddedByValue()                {}

// UnsafeReportServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportServer will
// result in compilation errors.
type UnsafeReportServer interface {
	mustEmbedUnimplementedReportServer()
}

func RegisterReportServer(s grpc.ServiceRegistrar, srv ReportServer) {
	// If the following call pancis, it indicates UnimplementedReportServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Report_ServiceDesc, srv)
}

func _Report_SubmitReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).SubmitReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_SubmitReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).SubmitReport(ctx, req.(*SubmitReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).GetReport(ctx, req.(*GetReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_ListReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).ListReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_ListReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).ListReports(ctx, req.(*ListReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_UpdateReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).UpdateReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_UpdateReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).UpdateReport(ctx, req.(*UpdateReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_GetReportCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).GetReportCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_GetReportCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).GetReportCategories(ctx, req.(*GetReportCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_UploadAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).UploadAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_UploadAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).UploadAttachment(ctx, req.(*UploadAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_GetReportStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).GetReportStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_GetReportStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).GetReportStatus(ctx, req.(*GetReportStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_CloseReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).CloseReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_CloseReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).CloseReport(ctx, req.(*CloseReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_AddReportComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReportCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).AddReportComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_AddReportComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).AddReportComment(ctx, req.(*AddReportCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Report_GetReportComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServer).GetReportComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Report_GetReportComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServer).GetReportComments(ctx, req.(*GetReportCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Report_ServiceDesc is the grpc.ServiceDesc for Report service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Report_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Report",
	HandlerType: (*ReportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitReport",
			Handler:    _Report_SubmitReport_Handler,
		},
		{
			MethodName: "GetReport",
			Handler:    _Report_GetReport_Handler,
		},
		{
			MethodName: "ListReports",
			Handler:    _Report_ListReports_Handler,
		},
		{
			MethodName: "UpdateReport",
			Handler:    _Report_UpdateReport_Handler,
		},
		{
			MethodName: "GetReportCategories",
			Handler:    _Report_GetReportCategories_Handler,
		},
		{
			MethodName: "UploadAttachment",
			Handler:    _Report_UploadAttachment_Handler,
		},
		{
			MethodName: "GetReportStatus",
			Handler:    _Report_GetReportStatus_Handler,
		},
		{
			MethodName: "CloseReport",
			Handler:    _Report_CloseReport_Handler,
		},
		{
			MethodName: "AddReportComment",
			Handler:    _Report_AddReportComment_Handler,
		},
		{
			MethodName: "GetReportComments",
			Handler:    _Report_GetReportComments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}

const (
	Saved_SaveItem_FullMethodName         = "/client.Saved/SaveItem"
	Saved_RemoveSaved_FullMethodName      = "/client.Saved/RemoveSaved"
	Saved_ListSaved_FullMethodName        = "/client.Saved/ListSaved"
	Saved_GetSavedItem_FullMethodName     = "/client.Saved/GetSavedItem"
	Saved_CreateCollection_FullMethodName = "/client.Saved/CreateCollection"
	Saved_UpdateCollection_FullMethodName = "/client.Saved/UpdateCollection"
	Saved_DeleteCollection_FullMethodName = "/client.Saved/DeleteCollection"
	Saved_ListCollections_FullMethodName  = "/client.Saved/ListCollections"
	Saved_GetCollection_FullMethodName    = "/client.Saved/GetCollection"
	Saved_MoveToCollection_FullMethodName = "/client.Saved/MoveToCollection"
	Saved_GetSavedStats_FullMethodName    = "/client.Saved/GetSavedStats"
	Saved_ExportSaved_FullMethodName      = "/client.Saved/ExportSaved"
)

// SavedClient is the client API for Saved service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SavedClient interface {
	SaveItem(ctx context.Context, in *SaveItemRequest, opts ...grpc.CallOption) (*SaveItemResponse, error)
	RemoveSaved(ctx context.Context, in *RemoveSavedRequest, opts ...grpc.CallOption) (*RemoveSavedResponse, error)
	ListSaved(ctx context.Context, in *ListSavedRequest, opts ...grpc.CallOption) (*ListSavedResponse, error)
	GetSavedItem(ctx context.Context, in *GetSavedItemRequest, opts ...grpc.CallOption) (*GetSavedItemResponse, error)
	CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *UpdateCollectionRequest, opts ...grpc.CallOption) (*UpdateCollectionResponse, error)
	DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error)
	ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error)
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error)
	MoveToCollection(ctx context.Context, in *MoveToCollectionRequest, opts ...grpc.CallOption) (*MoveToCollectionResponse, error)
	GetSavedStats(ctx context.Context, in *GetSavedStatsRequest, opts ...grpc.CallOption) (*GetSavedStatsResponse, error)
	ExportSaved(ctx context.Context, in *ExportSavedRequest, opts ...grpc.CallOption) (*ExportSavedResponse, error)
}

type savedClient struct {
	cc grpc.ClientConnInterface
}

func NewSavedClient(cc grpc.ClientConnInterface) SavedClient {
	return &savedClient{cc}
}

func (c *savedClient) SaveItem(ctx context.Context, in *SaveItemRequest, opts ...grpc.CallOption) (*SaveItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveItemResponse)
	err := c.cc.Invoke(ctx, Saved_SaveItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) RemoveSaved(ctx context.Context, in *RemoveSavedRequest, opts ...grpc.CallOption) (*RemoveSavedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveSavedResponse)
	err := c.cc.Invoke(ctx, Saved_RemoveSaved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) ListSaved(ctx context.Context, in *ListSavedRequest, opts ...grpc.CallOption) (*ListSavedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSavedResponse)
	err := c.cc.Invoke(ctx, Saved_ListSaved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) GetSavedItem(ctx context.Context, in *GetSavedItemRequest, opts ...grpc.CallOption) (*GetSavedItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSavedItemResponse)
	err := c.cc.Invoke(ctx, Saved_GetSavedItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCollectionResponse)
	err := c.cc.Invoke(ctx, Saved_CreateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) UpdateCollection(ctx context.Context, in *UpdateCollectionRequest, opts ...grpc.CallOption) (*UpdateCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCollectionResponse)
	err := c.cc.Invoke(ctx, Saved_UpdateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, Saved_DeleteCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCollectionsResponse)
	err := c.cc.Invoke(ctx, Saved_ListCollections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*GetCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCollectionResponse)
	err := c.cc.Invoke(ctx, Saved_GetCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) MoveToCollection(ctx context.Context, in *MoveToCollectionRequest, opts ...grpc.CallOption) (*MoveToCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveToCollectionResponse)
	err := c.cc.Invoke(ctx, Saved_MoveToCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) GetSavedStats(ctx context.Context, in *GetSavedStatsRequest, opts ...grpc.CallOption) (*GetSavedStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSavedStatsResponse)
	err := c.cc.Invoke(ctx, Saved_GetSavedStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *savedClient) ExportSaved(ctx context.Context, in *ExportSavedRequest, opts ...grpc.CallOption) (*ExportSavedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportSavedResponse)
	err := c.cc.Invoke(ctx, Saved_ExportSaved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SavedServer is the server API for Saved service.
// All implementations must embed UnimplementedSavedServer
// for forward compatibility.
type SavedServer interface {
	SaveItem(context.Context, *SaveItemRequest) (*SaveItemResponse, error)
	RemoveSaved(context.Context, *RemoveSavedRequest) (*RemoveSavedResponse, error)
	ListSaved(context.Context, *ListSavedRequest) (*ListSavedResponse, error)
	GetSavedItem(context.Context, *GetSavedItemRequest) (*GetSavedItemResponse, error)
	CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error)
	UpdateCollection(context.Context, *UpdateCollectionRequest) (*UpdateCollectionResponse, error)
	DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error)
	ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error)
	GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error)
	MoveToCollection(context.Context, *MoveToCollectionRequest) (*MoveToCollectionResponse, error)
	GetSavedStats(context.Context, *GetSavedStatsRequest) (*GetSavedStatsResponse, error)
	ExportSaved(context.Context, *ExportSavedRequest) (*ExportSavedResponse, error)
	mustEmbedUnimplementedSavedServer()
}

// UnimplementedSavedServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSavedServer struct{}

func (UnimplementedSavedServer) SaveItem(context.Context, *SaveItemRequest) (*SaveItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveItem not implemented")
}
func (UnimplementedSavedServer) RemoveSaved(context.Context, *RemoveSavedRequest) (*RemoveSavedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSaved not implemented")
}
func (UnimplementedSavedServer) ListSaved(context.Context, *ListSavedRequest) (*ListSavedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSaved not implemented")
}
func (UnimplementedSavedServer) GetSavedItem(context.Context, *GetSavedItemRequest) (*GetSavedItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSavedItem not implemented")
}
func (UnimplementedSavedServer) CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (UnimplementedSavedServer) UpdateCollection(context.Context, *UpdateCollectionRequest) (*UpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (UnimplementedSavedServer) DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (UnimplementedSavedServer) ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCollections not implemented")
}
func (UnimplementedSavedServer) GetCollection(context.Context, *GetCollectionRequest) (*GetCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedSavedServer) MoveToCollection(context.Context, *MoveToCollectionRequest) (*MoveToCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveToCollection not implemented")
}
func (UnimplementedSavedServer) GetSavedStats(context.Context, *GetSavedStatsRequest) (*GetSavedStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSavedStats not implemented")
}
func (UnimplementedSavedServer) ExportSaved(context.Context, *ExportSavedRequest) (*ExportSavedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportSaved not implemented")
}
func (UnimplementedSavedServer) mustEmbedUnimplementedSavedServer() {}
func (UnimplementedSavedServer) testEmbeddedByValue()               {}

// UnsafeSavedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SavedServer will
// result in compilation errors.
type UnsafeSavedServer interface {
	mustEmbedUnimplementedSavedServer()
}

func RegisterSavedServer(s grpc.ServiceRegistrar, srv SavedServer) {
	// If the following call pancis, it indicates UnimplementedSavedServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Saved_ServiceDesc, srv)
}

func _Saved_SaveItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).SaveItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_SaveItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).SaveItem(ctx, req.(*SaveItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_RemoveSaved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSavedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).RemoveSaved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_RemoveSaved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).RemoveSaved(ctx, req.(*RemoveSavedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_ListSaved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSavedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).ListSaved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_ListSaved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).ListSaved(ctx, req.(*ListSavedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_GetSavedItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSavedItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).GetSavedItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_GetSavedItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).GetSavedItem(ctx, req.(*GetSavedItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_CreateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).CreateCollection(ctx, req.(*CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_UpdateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).UpdateCollection(ctx, req.(*UpdateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_DeleteCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).DeleteCollection(ctx, req.(*DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_ListCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).ListCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_ListCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).ListCollections(ctx, req.(*ListCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_MoveToCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveToCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).MoveToCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_MoveToCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).MoveToCollection(ctx, req.(*MoveToCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_GetSavedStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSavedStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).GetSavedStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_GetSavedStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).GetSavedStats(ctx, req.(*GetSavedStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Saved_ExportSaved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportSavedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SavedServer).ExportSaved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Saved_ExportSaved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SavedServer).ExportSaved(ctx, req.(*ExportSavedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Saved_ServiceDesc is the grpc.ServiceDesc for Saved service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Saved_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Saved",
	HandlerType: (*SavedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveItem",
			Handler:    _Saved_SaveItem_Handler,
		},
		{
			MethodName: "RemoveSaved",
			Handler:    _Saved_RemoveSaved_Handler,
		},
		{
			MethodName: "ListSaved",
			Handler:    _Saved_ListSaved_Handler,
		},
		{
			MethodName: "GetSavedItem",
			Handler:    _Saved_GetSavedItem_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _Saved_CreateCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _Saved_UpdateCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _Saved_DeleteCollection_Handler,
		},
		{
			MethodName: "ListCollections",
			Handler:    _Saved_ListCollections_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _Saved_GetCollection_Handler,
		},
		{
			MethodName: "MoveToCollection",
			Handler:    _Saved_MoveToCollection_Handler,
		},
		{
			MethodName: "GetSavedStats",
			Handler:    _Saved_GetSavedStats_Handler,
		},
		{
			MethodName: "ExportSaved",
			Handler:    _Saved_ExportSaved_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}

const (
	Settings_GetSettings_FullMethodName           = "/client.Settings/GetSettings"
	Settings_UpdateSettings_FullMethodName        = "/client.Settings/UpdateSettings"
	Settings_GetPreferences_FullMethodName        = "/client.Settings/GetPreferences"
	Settings_UpdatePreferences_FullMethodName     = "/client.Settings/UpdatePreferences"
	Settings_UploadAvatar_FullMethodName          = "/client.Settings/UploadAvatar"
	Settings_DeleteAccount_FullMethodName         = "/client.Settings/DeleteAccount"
	Settings_ExportData_FullMethodName            = "/client.Settings/ExportData"
	Settings_GetPrivacySettings_FullMethodName    = "/client.Settings/GetPrivacySettings"
	Settings_UpdatePrivacySettings_FullMethodName = "/client.Settings/UpdatePrivacySettings"
)

// SettingsClient is the client API for Settings service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SettingsClient interface {
	GetSettings(ctx context.Context, in *GetSettingsRequest, opts ...grpc.CallOption) (*GetSettingsResponse, error)
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UpdateSettingsResponse, error)
	GetPreferences(ctx context.Context, in *GetPreferencesRequest, opts ...grpc.CallOption) (*GetPreferencesResponse, error)
	UpdatePreferences(ctx context.Context, in *UpdatePreferencesRequest, opts ...grpc.CallOption) (*UpdatePreferencesResponse, error)
	UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error)
	ExportData(ctx context.Context, in *ExportDataRequest, opts ...grpc.CallOption) (*ExportDataResponse, error)
	GetPrivacySettings(ctx context.Context, in *GetPrivacySettingsRequest, opts ...grpc.CallOption) (*GetPrivacySettingsResponse, error)
	UpdatePrivacySettings(ctx context.Context, in *UpdatePrivacySettingsRequest, opts ...grpc.CallOption) (*UpdatePrivacySettingsResponse, error)
}

type settingsClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingsClient(cc grpc.ClientConnInterface) SettingsClient {
	return &settingsClient{cc}
}

func (c *settingsClient) GetSettings(ctx context.Context, in *GetSettingsRequest, opts ...grpc.CallOption) (*GetSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSettingsResponse)
	err := c.cc.Invoke(ctx, Settings_GetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UpdateSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSettingsResponse)
	err := c.cc.Invoke(ctx, Settings_UpdateSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetPreferences(ctx context.Context, in *GetPreferencesRequest, opts ...grpc.CallOption) (*GetPreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPreferencesResponse)
	err := c.cc.Invoke(ctx, Settings_GetPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) UpdatePreferences(ctx context.Context, in *UpdatePreferencesRequest, opts ...grpc.CallOption) (*UpdatePreferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePreferencesResponse)
	err := c.cc.Invoke(ctx, Settings_UpdatePreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadAvatarResponse)
	err := c.cc.Invoke(ctx, Settings_UploadAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAccountResponse)
	err := c.cc.Invoke(ctx, Settings_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) ExportData(ctx context.Context, in *ExportDataRequest, opts ...grpc.CallOption) (*ExportDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportDataResponse)
	err := c.cc.Invoke(ctx, Settings_ExportData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetPrivacySettings(ctx context.Context, in *GetPrivacySettingsRequest, opts ...grpc.CallOption) (*GetPrivacySettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivacySettingsResponse)
	err := c.cc.Invoke(ctx, Settings_GetPrivacySettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) UpdatePrivacySettings(ctx context.Context, in *UpdatePrivacySettingsRequest, opts ...grpc.CallOption) (*UpdatePrivacySettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePrivacySettingsResponse)
	err := c.cc.Invoke(ctx, Settings_UpdatePrivacySettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsServer is the server API for Settings service.
// All implementations must embed UnimplementedSettingsServer
// for forward compatibility.
type SettingsServer interface {
	GetSettings(context.Context, *GetSettingsRequest) (*GetSettingsResponse, error)
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*UpdateSettingsResponse, error)
	GetPreferences(context.Context, *GetPreferencesRequest) (*GetPreferencesResponse, error)
	UpdatePreferences(context.Context, *UpdatePreferencesRequest) (*UpdatePreferencesResponse, error)
	UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error)
	ExportData(context.Context, *ExportDataRequest) (*ExportDataResponse, error)
	GetPrivacySettings(context.Context, *GetPrivacySettingsRequest) (*GetPrivacySettingsResponse, error)
	UpdatePrivacySettings(context.Context, *UpdatePrivacySettingsRequest) (*UpdatePrivacySettingsResponse, error)
	mustEmbedUnimplementedSettingsServer()
}

// UnimplementedSettingsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSettingsServer struct{}

func (UnimplementedSettingsServer) GetSettings(context.Context, *GetSettingsRequest) (*GetSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSettings not implemented")
}
func (UnimplementedSettingsServer) UpdateSettings(context.Context, *UpdateSettingsRequest) (*UpdateSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (UnimplementedSettingsServer) GetPreferences(context.Context, *GetPreferencesRequest) (*GetPreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPreferences not implemented")
}
func (UnimplementedSettingsServer) UpdatePreferences(context.Context, *UpdatePreferencesRequest) (*UpdatePreferencesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePreferences not implemented")
}
func (UnimplementedSettingsServer) UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadAvatar not implemented")
}
func (UnimplementedSettingsServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedSettingsServer) ExportData(context.Context, *ExportDataRequest) (*ExportDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportData not implemented")
}
func (UnimplementedSettingsServer) GetPrivacySettings(context.Context, *GetPrivacySettingsRequest) (*GetPrivacySettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivacySettings not implemented")
}
func (UnimplementedSettingsServer) UpdatePrivacySettings(context.Context, *UpdatePrivacySettingsRequest) (*UpdatePrivacySettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrivacySettings not implemented")
}
func (UnimplementedSettingsServer) mustEmbedUnimplementedSettingsServer() {}
func (UnimplementedSettingsServer) testEmbeddedByValue()                  {}

// UnsafeSettingsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingsServer will
// result in compilation errors.
type UnsafeSettingsServer interface {
	mustEmbedUnimplementedSettingsServer()
}

func RegisterSettingsServer(s grpc.ServiceRegistrar, srv SettingsServer) {
	// If the following call pancis, it indicates UnimplementedSettingsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Settings_ServiceDesc, srv)
}

func _Settings_GetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_GetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetSettings(ctx, req.(*GetSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_UpdateSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_GetPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetPreferences(ctx, req.(*GetPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_UpdatePreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).UpdatePreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_UpdatePreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).UpdatePreferences(ctx, req.(*UpdatePreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_UploadAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAvatarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).UploadAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_UploadAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).UploadAvatar(ctx, req.(*UploadAvatarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_ExportData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).ExportData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_ExportData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).ExportData(ctx, req.(*ExportDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetPrivacySettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivacySettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetPrivacySettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_GetPrivacySettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetPrivacySettings(ctx, req.(*GetPrivacySettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_UpdatePrivacySettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePrivacySettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).UpdatePrivacySettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Settings_UpdatePrivacySettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).UpdatePrivacySettings(ctx, req.(*UpdatePrivacySettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Settings_ServiceDesc is the grpc.ServiceDesc for Settings service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Settings_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Settings",
	HandlerType: (*SettingsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSettings",
			Handler:    _Settings_GetSettings_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _Settings_UpdateSettings_Handler,
		},
		{
			MethodName: "GetPreferences",
			Handler:    _Settings_GetPreferences_Handler,
		},
		{
			MethodName: "UpdatePreferences",
			Handler:    _Settings_UpdatePreferences_Handler,
		},
		{
			MethodName: "UploadAvatar",
			Handler:    _Settings_UploadAvatar_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _Settings_DeleteAccount_Handler,
		},
		{
			MethodName: "ExportData",
			Handler:    _Settings_ExportData_Handler,
		},
		{
			MethodName: "GetPrivacySettings",
			Handler:    _Settings_GetPrivacySettings_Handler,
		},
		{
			MethodName: "UpdatePrivacySettings",
			Handler:    _Settings_UpdatePrivacySettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}

const (
	Articles_ListArticles_FullMethodName      = "/client.Articles/ListArticles"
	Articles_GetArticle_FullMethodName        = "/client.Articles/GetArticle"
	Articles_LikeArticle_FullMethodName       = "/client.Articles/LikeArticle"
	Articles_ShareArticle_FullMethodName      = "/client.Articles/ShareArticle"
	Articles_GetAuthorArticles_FullMethodName = "/client.Articles/GetAuthorArticles"
)

// ArticlesClient is the client API for Articles service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ArticlesClient interface {
	ListArticles(ctx context.Context, in *ListArticlesRequest, opts ...grpc.CallOption) (*ListArticlesResponse, error)
	GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*GetArticleResponse, error)
	LikeArticle(ctx context.Context, in *LikeArticleRequest, opts ...grpc.CallOption) (*LikeArticleResponse, error)
	ShareArticle(ctx context.Context, in *ShareArticleRequest, opts ...grpc.CallOption) (*ShareArticleResponse, error)
	GetAuthorArticles(ctx context.Context, in *GetAuthorArticlesRequest, opts ...grpc.CallOption) (*GetAuthorArticlesResponse, error)
}

type articlesClient struct {
	cc grpc.ClientConnInterface
}

func NewArticlesClient(cc grpc.ClientConnInterface) ArticlesClient {
	return &articlesClient{cc}
}

func (c *articlesClient) ListArticles(ctx context.Context, in *ListArticlesRequest, opts ...grpc.CallOption) (*ListArticlesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArticlesResponse)
	err := c.cc.Invoke(ctx, Articles_ListArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articlesClient) GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*GetArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArticleResponse)
	err := c.cc.Invoke(ctx, Articles_GetArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articlesClient) LikeArticle(ctx context.Context, in *LikeArticleRequest, opts ...grpc.CallOption) (*LikeArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LikeArticleResponse)
	err := c.cc.Invoke(ctx, Articles_LikeArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articlesClient) ShareArticle(ctx context.Context, in *ShareArticleRequest, opts ...grpc.CallOption) (*ShareArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShareArticleResponse)
	err := c.cc.Invoke(ctx, Articles_ShareArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articlesClient) GetAuthorArticles(ctx context.Context, in *GetAuthorArticlesRequest, opts ...grpc.CallOption) (*GetAuthorArticlesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuthorArticlesResponse)
	err := c.cc.Invoke(ctx, Articles_GetAuthorArticles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArticlesServer is the server API for Articles service.
// All implementations must embed UnimplementedArticlesServer
// for forward compatibility.
type ArticlesServer interface {
	ListArticles(context.Context, *ListArticlesRequest) (*ListArticlesResponse, error)
	GetArticle(context.Context, *GetArticleRequest) (*GetArticleResponse, error)
	LikeArticle(context.Context, *LikeArticleRequest) (*LikeArticleResponse, error)
	ShareArticle(context.Context, *ShareArticleRequest) (*ShareArticleResponse, error)
	GetAuthorArticles(context.Context, *GetAuthorArticlesRequest) (*GetAuthorArticlesResponse, error)
	mustEmbedUnimplementedArticlesServer()
}

// UnimplementedArticlesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArticlesServer struct{}

func (UnimplementedArticlesServer) ListArticles(context.Context, *ListArticlesRequest) (*ListArticlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArticles not implemented")
}
func (UnimplementedArticlesServer) GetArticle(context.Context, *GetArticleRequest) (*GetArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticle not implemented")
}
func (UnimplementedArticlesServer) LikeArticle(context.Context, *LikeArticleRequest) (*LikeArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LikeArticle not implemented")
}
func (UnimplementedArticlesServer) ShareArticle(context.Context, *ShareArticleRequest) (*ShareArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShareArticle not implemented")
}
func (UnimplementedArticlesServer) GetAuthorArticles(context.Context, *GetAuthorArticlesRequest) (*GetAuthorArticlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthorArticles not implemented")
}
func (UnimplementedArticlesServer) mustEmbedUnimplementedArticlesServer() {}
func (UnimplementedArticlesServer) testEmbeddedByValue()                  {}

// UnsafeArticlesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArticlesServer will
// result in compilation errors.
type UnsafeArticlesServer interface {
	mustEmbedUnimplementedArticlesServer()
}

func RegisterArticlesServer(s grpc.ServiceRegistrar, srv ArticlesServer) {
	// If the following call pancis, it indicates UnimplementedArticlesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Articles_ServiceDesc, srv)
}

func _Articles_ListArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArticlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticlesServer).ListArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Articles_ListArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticlesServer).ListArticles(ctx, req.(*ListArticlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Articles_GetArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticlesServer).GetArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Articles_GetArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticlesServer).GetArticle(ctx, req.(*GetArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Articles_LikeArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikeArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticlesServer).LikeArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Articles_LikeArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticlesServer).LikeArticle(ctx, req.(*LikeArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Articles_ShareArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticlesServer).ShareArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Articles_ShareArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticlesServer).ShareArticle(ctx, req.(*ShareArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Articles_GetAuthorArticles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthorArticlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticlesServer).GetAuthorArticles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Articles_GetAuthorArticles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticlesServer).GetAuthorArticles(ctx, req.(*GetAuthorArticlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Articles_ServiceDesc is the grpc.ServiceDesc for Articles service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Articles_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "client.Articles",
	HandlerType: (*ArticlesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListArticles",
			Handler:    _Articles_ListArticles_Handler,
		},
		{
			MethodName: "GetArticle",
			Handler:    _Articles_GetArticle_Handler,
		},
		{
			MethodName: "LikeArticle",
			Handler:    _Articles_LikeArticle_Handler,
		},
		{
			MethodName: "ShareArticle",
			Handler:    _Articles_ShareArticle_Handler,
		},
		{
			MethodName: "GetAuthorArticles",
			Handler:    _Articles_GetAuthorArticles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/microservices/client/api/v1/client.proto",
}
